# 가상메모리, 페이지테이블, 페이지폴트, 스레싱

## 가상메모리
* 가상 메모리는 컴퓨터가 실제로 이용가능한 메모리 자원을 추상화하여 이를 사용하는 사용자에게 매우 큰 메모리로 보이게 만드는 메모리 관리 기법
* 페이지 테이블, MMU, TLB, 페이지 폴트 등을 모두 포함

### 참고
* 가상 주소는 MMU(Memory Management Unit)와 페이지 테이블에 의해 실제 주소로 변환됨
* MMU는 CPU와 메모리 사이에 위치한 하드웨어 컴포넌트로, 가상 주소와 물리 주소 사이의 변환을 담당
    * MMU가 주소 변환을 할 때 페이지테이블, TLB(Translation Lookaside Buffer, 일종의 주소 캐시)를 참조해서 주소 변환을 함
    * 페이지 테이블의 생성, 수정, 삭제는 OS가 담당
* 페이지 : 가상 메모리를 사용하는 최소 크기 단위
* 프레임 : 실제 메모리를 사용하는 최소 크기 단위

## 페이지 테이블
* 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있는 페이지 테이블로 관리
* 속도 향상을 위해 캐싱 계층인 TLB 사용

## 서로 다른 프로세스 간 가상 주소와 물리 주소
![alt text](../Images/서로%20다른%20프로세스%20간%20가상%20주소와%20실제%20주소.png)
* 위 사진과 같이 서로 다른 프로세스의 가상 주소가 달라도 실제 물리 주소는 다름
* 독립적으로 관리

## 페이지 폴트
* 가상 메모리가 실제 메모리보다 큰데, 요청한 페이지가 실제 메모리에 없다면 페이지 폴트가 발생함
* 프로세스가 참조하려는 주소가 가리키는 페이지가 현재 물리 메모리(RAM)에 없을 때 발생하는 현상
* 처음에 프로세스의 메모리 전체 내용을 올리는 것이 아닌 필요한 부분만 부분적으로 올리기 때문에 이러한 현상이 발생

## 페이지 스와핑 과정
1. 페이지 폴트 발생
2. os에게 트랩 전달
3. 페이지 폴트 유효성 검사(ex : 정상적인 접근인지)
4. 메모리에 빈 프레임 존재?
    * YES : Disk에서 페이지 읽어옴 (Swap-in)
    * NO :
        * 페이지 교체 알고리즘 수행
        * 선택된 페이지 Disk로 내보냄 (Swap-out)
        * Disk에서 페이지 읽어옴 (Swap-in)

## 스레싱
* 실제 프로세스 실행보다 스와핑 작업에 대부분의 시간이 소요되는 현상
* 페이지 폴트가 빈번하게 발생하는 경우
![alt text](../Images/스레싱.png)
* CPU가 메모리로부터 일을 받아오려 하는데 페이지 폴트 발생해서 CPU의 대기시간이 길어지면 OS가 CPU한테 일을 더 시키고 결국 악순환 발생
* 하드웨어적 해결 : 메모리를 늘리거나 HDD를 SSD로 교체
* 소프트웨어적 해결 : 작업세트, PFF
### 작업세트
* working set
* 프로세스의 과거 이력을 기반으로 많이 사용하는 페이지 집합을 만들어 한번에 미리 메모리에 로드
### PFF
* Page Fault Frequency
* 페이지 폴트 발생 빈도를 모니터링하여, 메모리 프레임의 할당량을 동적으로 조절
* 페이지 폴트 빈도가 상한선 도달 : 해당 프로세스에 더 많은 프레임 할당

## 기싱 메모리의 장점
* 메모리의 효율적 사용 : 필요한 시점에 해당 메모리 페이지만 동적으로 불러오기 때문에 제한된 램 내에서도 대용량 프로그램을 효율적으로 사용 가능(Demand Paging)
* 메모리 과잉 할당 : 운영체제는 각 프로세스에 가상 주소 공간을 넉넉하게 할당하여 실제 램보다 훨씬 큰 주소 공간 사용 가능하여 메모리 자원을 최대한 효율적으로 배분 가능
* 프로세스 간 메모리 보호 : 독자적인 가상 주소 공간을 갖고, 동일한 가상 공간이라도 서로 다른 메모리 영역에 매핑되기 때문에, 오류나 데이터 충돌이 다른 프로세스에 영향을 주지 않고, 특정 프로세스의 악의적 접근 방지 가능
* 메모리 접근 제어 : 가상 메모리를 통해 일정한 페이지로 나누어 관리하는데, 페이지 단위로 읽기, 쓰기, 실행 권한 설정 가능 (보안 위협 방지 가능)